//// 1. 테트리스에 필요한 자원(좌표, 점수 등) 저장할 구조체 만들기.
//// 2. 키보드 방향키, 스페이스바 인식하는 방법 만들기.
//// 3. 명령 프롬프트상 커서 좌표 설정하기.
//// 4. 테트리스에서 사용하는 도형을 나타내는 방법 만들기.
//// 5. 도형 돌리는 방법, 회전하는 방법 만들기.
//// 6. 도형이 벽, 바닥, 다른 도형과 부딪힐 때 판단하는 방법 만들기.
//// 7. 현재 나올 도형과 다음 도형을 미리 랜덤으로 받을 방법 만들기.
//// 8. 키보드 방향키 따라 도형 움직이고 인식하는 방법 만들기.
//// 9. 도형이 한 줄을 채웠을 때 인식하고 지우는 방법 만들기.
//// 10. 9번 상황이 되기 전 도형이 땅에 부딪히거나 닿아서 움직일 수 없을 경우 도형 쌓는 방법 만들기.
//// 11. 눈에 보이는 테트리스가 되도록 UI 만들기.
//
//
//#include <stdio.h>
//#include <conio.h> // _getch() 함수 사용을 위한 헤더 파일.
//#include <Windows.h> // COORD 자료형 사용을 위한 헤더 파일.
//
//
//// 1. 테트리스에 필요한 자원(좌표, 점수 등) 저장할 구조체 만들기.
//// 레벨, 게임오버, 점수, 도형 방향, 도형 절대좌표 및 현재좌표, 현재 및 다음 블럭 자료형
//typedef struct _tetris {
//	int level;
//	int gameover;
//	int score;
//	int rotation;
//	int absX, absY;
//	int curX, curY;
//	int curblock;
//	int nextblock;
//    int t;
//}Tetris;
//
//
//// 2. 키보드 방향키, 스페이스바 인식하는 방법 만들기.
//// 방향키 및 스페이스바 코드값
//#define UP 72
//#define DOWN 80
//#define LEFT 75
//#define RIGHT 77
//#define SPACEBAR 32
//
//
//// 3. 명령 프롬프트상 커서 좌표 설정하기.
//// COORD: x좌표, y좌표 저장할 수 있는 자료형.
////typedef struct _COORD {
////	short x;
////	short y;
////}COORD;
//
//// 커서 이동시키는 함수 만들기
//void setCursor(int x, int y) {
//	COORD pos = { x,y };
//	SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
//	// 콘솔 위치 지정하는 함수. 표준 출력 핸들을 x, y값을 넣은 COORD형 변수 pos 위치에 커서 위치 지정한다는 것.
//}
//
//// 도형을 움직여도 커서 안 보이게 만들기
//void removeCursor() {
//	CONSOLE_CURSOR_INFO curinfo;
//	curinfo.bVisible = 0;
//	GetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &curinfo);
//	// 표준 출력 핸들을 가지고 오고, CONSOR_CURSOR_INFO 형식의 curinfo의 주소(0) 가져와서 안 보이게 하겠다는 것.
//}
//
//
//// 4. 테트리스에서 사용하는 도형을 나타내는 방법 만들기.
//// 테트리스 도형 개수 7, 각 도형 방향 개수 4, 세로 길이 4, 가로 길이 4
//int blocks[7][4][4][4] = {
//{
//    {0,0,0,0,
//    0,1,1,0,
//    0,1,1,0,
//    0,0,0,0},
//    
//    {0,0,0,0,
//    0,1,1,0,
//    0,1,1,0,
//    0,0,0,0},
//
//    {0,0,0,0,
//    0,1,1,0,
//    0,1,1,0,
//    0,0,0,0},
//    
//    {0,0,0,0,
//    0,1,1,0,
//    0,1,1,0,
//    0,0,0,0}},
//
//{
//    {0,0,0,0,
//    0,0,0,0,
//    1,1,1,1,
//    0,0,0,0},
//    
//    {0,1,0,0,
//    0,1,0,0,
//    0,1,0,0,
//    0,1,0,0},
//
//    {0,0,0,0,
//    0,0,0,0,
//    1,1,1,1,
//    0,0,0,0},
//    
//    {0,1,0,0,
//    0,1,0,0,
//    0,1,0,0,
//    0,1,0,0}},
//
//{
//    {0,0,0,0,
//    1,1,0,0,
//    0,1,1,0,
//    0,0,0,0},
//    
//    {0,0,0,0,
//    0,0,1,0,
//    0,1,1,0,
//    0,1,0,0},
//
//    {0,0,0,0,
//    1,1,0,0,
//    0,1,1,0,
//    0,0,0,0},
//    
//    {0,0,0,0,
//    0,0,1,0,
//    0,1,1,0,
//    0,1,0,0}},
//
//{
//    {0,0,0,0,
//    0,1,1,0,
//    1,1,0,0,
//    0,0,0,0},
//    
//    {0,0,0,0,
//    1,0,0,0,
//    1,1,0,0,
//    0,1,0,0},
//
//    {0,0,0,0,
//    0,1,1,0,
//    1,1,0,0,
//    0,0,0,0},
//    
//    {0,0,0,0,
//    1,0,0,0,
//    1,1,0,0,
//    0,1,0,0}},
//
//{
//    {0,0,0,0,
//    0,0,1,0,
//    1,1,1,0,
//    0,0,0,0},
//    
//    {0,0,0,0,
//    1,1,0,0,
//    0,1,0,0,
//    0,1,0,0},
// 
//    {0,0,0,0,
//    0,0,0,0,
//    1,1,1,0,
//    1,0,0,0},
//    
//    {0,0,0,0,
//    0,1,0,0,
//    0,1,0,0,
//    0,1,1,0}},
//
//{
//    {0,0,0,0,
//    1,0,0,0,
//    1,1,1,0,
//    0,0,0,0},
//
//    {0,0,0,0,
//    0,1,0,0,
//    0,1,0,0,
//    1,1,0,0},
// 
//    {0,0,0,0,
//    0,0,0,0,
//    1,1,1,0,
//    0,0,1,0},
//    
//    {0,0,0,0,
//    0,1,1,0,
//    0,1,0,0,
//    0,1,0,0}},
//
//{
//    {0,0,0,0,
//    0,1,0,0,
//    1,1,1,0,
//    0,0,0,0},
//    
//    {0,0,0,0,
//    0,1,0,0,
//    0,1,1,0,
//    0,1,0,0},
//
//    {0,0,0,0,
//    0,0,0,0,
//    1,1,1,0,
//    0,1,0,0},
//    
//    {0,0,0,0,
//    0,1,0,0,
//    1,1,0,0,
//    0,1,0,0}}
//}; 
//// 블록모양 저장 4*4공간에 블록을 표현 
//// blcoks[b_type][b_rotation][i][j]로 사용 
//
//
//// 5. 도형 돌리는 방법, 회전하는 방법 만들기.
//// 회전은 0,1,2,3 네 번째를 넘어가면 다시 원래 형태로 돌아와야 하므로
//// 구조체에서 특정 버튼을 누르면 rotation이 기존 rotation 값 + 1을 하고 % 4 값으로 회전하도록.
//// 이렇게 하면 나머지 값이 0~3까지만 남게 된다.
//
//
//// 6. 도형이 벽, 바닥, 다른 도형과 부딪힐 때 판단하는 방법 만들기.
//// 벽과 바닥은 1로 만들어서 ■ 출력해 벽이랑 바닥으로 인식하고, 
//// 빈 공간은 0으로 만들어서 '  ' 띄어쓰기 두 번으로 출력하게 설정.
//
//
//// 6-1. 테두리를 어떤 방식으로 설정?
//// 배열로 테두리를 생성해야 한다. 
//// 위에서 0과 1로 설정한다고 했으니 테트리스 도형처럼 2차원 배열로 생성.
//char gameboard[14][22];
//
//
//// 6-2. 생성된 블럭은 테두리와 어떤 관계?
//// 생성되는 블럭들은 구조체의 curblock 값에 맞게 gameboard에 그려야 함.
//// 구조체의 absX와 abxY 위치에 블럭을 그려 넣으면 된다.
//// 그래서 절대 좌표를 계속 바뀌는 현재 좌표 외에 따로 선언해 둔 것.
//// 사용자가 이동을 하지 않아도 한 칸씩 아래로 떨어지는 것 표현 => 현재 좌표 curY 값 1 증가.
//// 단, 여기서 끝내면 이전 생성 블럭과 한 칸 아래로 내려간 블럭이 연달아 출력되는 오류 발생하므로,
//// 이전에 그린 도형은 제거하는 함수가 필요함.
//
//void removeCurrentBlock(Tetris t) {
//    for (int i = 0; i < 4; i++) {
//        for (int j = 0; j < 4; j++) {
//            if (blocks[t.curblock][t.rotation][j][i] == 1) {
//                setCursor((i + t.curX) * 2 + t.absX, j + t.curY + t.absY);
//                printf("  "); 
//                // 아래로 한 칸 떨어지기 전 도형이 있던 부분을 curX, absX와 curY, absY를 기점으로 "  "로 바꾸는 기능.
//                // 도형이 떨어질 때, 한 라인이 채워져서 제거될 때, 도형 회전할 때 이 함수 사용.
//            }
//        }
//    }
//}
//
//
//// 6-3. 벽에 충돌할 때와 바닥에 충돌할 때 차이는? // 299줄에 코드 작성.
//int FRAME_HEIGHT = 22;
//int FRAME_WIDTH = 14; // 게임보드의 높이와 너비.
//
//
//// 6-4. 벽에 충돌하고 회전하면 어떻게 처리?
//
//
//
//
//// 7. 현재 나올 도형과 다음 도형을 미리 랜덤으로 받을 방법 만들기.
//// 8. 키보드 방향키 따라 도형 움직이고 인식하는 방법 만들기.
//// 9. 도형이 한 줄을 채웠을 때 인식하고 지우는 방법 만들기.
//// 10. 9번 상황이 되기 전 도형이 땅에 부딪히거나 닿아서 움직일 수 없을 경우 도형 쌓는 방법 만들기.
//// 11. 눈에 보이는 테트리스가 되도록 UI 만들기.
//
//
//int collisionCheck(Tetris t)
//{
//    int dat = 0;
//    for (int i = 0; i < 4; i++) {
//        for (int j = 0; j < 4; j++) {
//            if ((((t.curX) + j) == 0) || ((t.curX + j) == FRAME_WIDTH - 1))
//                dat = 1;
//            else
//                dat = gameboard[t.curY + i][t.curX + j];
//            if ((blocks[t.curblock][t.rotation][i][j] == 1) && (dat == 1))
//                return 1;
//        }
//    }
//    return 0;
//}
//
//
//void main() {
//
//	// 2. 키보드 방향키, 스페이스바 인식하는 방법 만들기.
//	char key;
//	key = _getch(); // _getch() 함수는 키보드 키 인식하는 함수.
//	while (_kbhit()) {
//		key = _getch();
//		switch (key) {
//		case UP:
//            tmpT = t;
//            tmpT.rotation = (tmpT.rotation + 1) % 4;
//            if (collisionCheck(tmpT) == 0) {
//                removeCurrentBlock(t);
//                t.rotation = tmpT.rotation;
//                showCurrentBlock(t);
//            }
//			break;
//		case DOWN:
//			break;
//		case LEFT:
//			break;
//		case RIGHT:
//			break;
//		}
//		if (key == SPACEBAR) { // 방향키와 스페이스바 동시 사용을 위해서 if문 사용.
//
//		}
//	}
//
//
//    for (int y = 0; y < FRAME_HEIGHT; y++) {
//        for (int x = 0; x < FRAME_WIDTH; x++) {
//            if ((x == 0) || (x == FRAME_WIDTH - 1))
//                gameboard[y][x] = 1;
//            else if (y == FRAME_HEIGHT - 1)
//                gameboard[y][x] = 1;
//            else
//                gameboard[y][x] = 0;
//        }
//    }
//
//}